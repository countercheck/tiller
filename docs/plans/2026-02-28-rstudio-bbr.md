# RStudio Server + bbr Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Deploy RStudio Server on the existing Azure VM and ship the `bbr` R package, giving the breeder and analyst a browser-based R environment pre-connected to Breedbase.

**Architecture:** `bootstrap.sh` installs R and RStudio Server; `deploy.sh` creates OS user accounts (`breeder`, `analyst`) and installs `bbr` into the system R library; nginx proxies `/rstudio/` to RStudio Server on port 8787. `bbr` wraps httr2 to make BrAPI v1.3 calls with token auth, returning tidy data frames.

**Tech Stack:** Bash, R, httr2, httptest2, testthat, nginx, RStudio Server (open source)

**Note on QBMS:** The design called for wrapping QBMS, but QBMS uses a global state model and is built around username/password auth, which makes it difficult to wrap cleanly with token auth and test in isolation. `bbr` uses httr2 directly — it is still BrAPI-based (QBMS is a BrAPI client; `bbr` is too, just thinner and testable). If you want to layer QBMS on top later, the `bbr_con` object makes that straightforward.

---

### Task 1: R package skeleton

**Files:**
- Create: `r-package/DESCRIPTION`
- Create: `r-package/NAMESPACE`
- Create: `r-package/LICENSE`
- Create: `r-package/R/connect.R`
- Create: `r-package/R/trials.R`
- Create: `r-package/R/germplasm.R`
- Create: `r-package/R/observations.R`
- Create: `r-package/tests/testthat.R`

**Step 1: Create DESCRIPTION**

```
Package: bbr
Title: Breedbase R Client
Version: 0.1.0
Authors@R:
    person("Tiller", "Dev", role = c("aut", "cre"),
           email = "dev@tiller-ag.org")
Description: Thin R client for Breedbase BrAPI v1.3 endpoints. Wraps
    httr2 to provide bb_connect() for token authentication and query
    functions that return tidy data frames.
License: MIT + file LICENSE
Encoding: UTF-8
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.3.2
Imports:
    httr2
Suggests:
    httptest2,
    testthat (>= 3.0.0),
    withr
Config/testthat/edition: 3
```

**Step 2: Create LICENSE**

```
YEAR: 2026
COPYRIGHT HOLDER: Tiller
```

**Step 3: Create NAMESPACE (stub — will be overwritten by roxygen2)**

```
# Generated by roxygen2: do not edit by hand
```

**Step 4: Create stub R files (one line each for now)**

`r-package/R/connect.R`: `# bb_connect — see Task 2`
`r-package/R/trials.R`: `# get_trials — see Task 3`
`r-package/R/germplasm.R`: `# get_germplasm — see Task 4`
`r-package/R/observations.R`: `# get_observations — see Task 5`

**Step 5: Create tests/testthat.R**

```r
library(testthat)
library(bbr)

test_check("bbr")
```

**Step 6: Verify package structure loads**

Run from `r-package/`:
```bash
Rscript -e "devtools::load_all('.')"
```
Expected: no errors (just empty package)

**Step 7: Commit**

```bash
git add r-package/
git commit -m "chore: scaffold bbr R package structure"
```

---

### Task 2: bb_connect() — TDD

**Files:**
- Modify: `r-package/R/connect.R`
- Create: `r-package/tests/testthat/test-connect.R`

**BrAPI background:** `bb_connect()` stores a URL and BrAPI token. The token is obtained from the Breedbase web UI: Admin → User Management → generate API token. Stored in `~/.Renviron` as `BB_URL` and `BB_TOKEN`.

**Step 1: Write the failing tests**

`r-package/tests/testthat/test-connect.R`:
```r
test_that("bb_connect() errors with a clear message when BB_URL is empty", {
  withr::with_envvar(c(BB_URL = "", BB_TOKEN = "tok"), {
    expect_error(bb_connect(), "BB_URL is not set")
  })
})

test_that("bb_connect() errors with a clear message when BB_TOKEN is empty", {
  withr::with_envvar(c(BB_URL = "https://example.com", BB_TOKEN = ""), {
    expect_error(bb_connect(), "BB_TOKEN is not set")
  })
})

test_that("bb_connect() returns a bbr_con object with url and token", {
  con <- bb_connect("https://example.com", "mytoken")
  expect_s3_class(con, "bbr_con")
  expect_equal(con$url, "https://example.com")
  expect_equal(con$token, "mytoken")
})

test_that("bb_connect() strips trailing slash from URL", {
  con <- bb_connect("https://example.com/", "mytoken")
  expect_equal(con$url, "https://example.com")
})
```

**Step 2: Run tests — expect FAIL**

```bash
cd r-package && Rscript -e "devtools::test(filter='connect')"
```
Expected: Error — `bb_connect` not found

**Step 3: Implement bb_connect()**

`r-package/R/connect.R`:
```r
#' Create a Breedbase connection
#'
#' @param url Base URL of the Breedbase instance. Defaults to `BB_URL` env var.
#' @param token BrAPI authentication token. Defaults to `BB_TOKEN` env var.
#' @return A `bbr_con` object (list with `url` and `token`).
#' @export
bb_connect <- function(url   = Sys.getenv("BB_URL"),
                       token = Sys.getenv("BB_TOKEN")) {
  if (!nzchar(url)) {
    stop("BB_URL is not set. Add `BB_URL=https://...` to ~/.Renviron.", call. = FALSE)
  }
  if (!nzchar(token)) {
    stop("BB_TOKEN is not set. Add `BB_TOKEN=...` to ~/.Renviron.", call. = FALSE)
  }
  structure(
    list(url = sub("/$", "", url), token = token),
    class = "bbr_con"
  )
}

#' @export
print.bbr_con <- function(x, ...) {
  cat("<bbr_con>\n")
  cat("  URL:", x$url, "\n")
  cat("  Token: [set]\n")
  invisible(x)
}

# Internal: build a base httr2 request authenticated for this connection.
# Not exported — used by get_trials(), get_germplasm(), get_observations().
bbr_request <- function(con, path) {
  stopifnot(inherits(con, "bbr_con"))
  httr2::request(con$url) |>
    httr2::req_url_path_append(path) |>
    httr2::req_headers(Authorization = paste("Bearer", con$token)) |>
    httr2::req_error(is_error = function(resp) httr2::resp_status(resp) >= 400)
}
```

**Step 4: Run tests — expect PASS**

```bash
Rscript -e "devtools::test(filter='connect')"
```
Expected: 4 tests passing

**Step 5: Regenerate NAMESPACE**

```bash
Rscript -e "devtools::document()"
```

**Step 6: Commit**

```bash
git add r-package/R/connect.R r-package/tests/testthat/test-connect.R r-package/NAMESPACE
git commit -m "feat(bbr): add bb_connect() with token auth"
```

---

### Task 3: get_trials() — TDD

**Files:**
- Modify: `r-package/R/trials.R`
- Create: `r-package/tests/testthat/test-trials.R`
- Create: `r-package/tests/testthat/example.com/brapi/v1/trials.json`

**BrAPI background:** `GET /brapi/v1/trials` returns a paged list of trials. In Breedbase, a "trial" (`trialDbId`) is the top-level experiment container (e.g., "2024 AB Barley Yield"). Individual location/year instances are "studies" (`studyDbId`). `get_trials()` returns the trial list — the breeder uses these IDs to query studies next (Breedbase UI shows both).

**Step 1: Create the httptest2 fixture**

Directory: `r-package/tests/testthat/example.com/brapi/v1/`

File: `trials.json`
```json
{
  "metadata": {
    "pagination": {"totalCount": 2, "pageSize": 1000, "totalPages": 1, "currentPage": 0},
    "status": [],
    "datafiles": []
  },
  "result": {
    "data": [
      {
        "trialDbId": "1",
        "trialName": "2024 AB Barley Yield Trial",
        "programName": "AB_Barley",
        "startDate": "2024-05-01",
        "endDate": "2024-09-30",
        "active": true
      },
      {
        "trialDbId": "2",
        "trialName": "2023 AB Barley Yield Trial",
        "programName": "AB_Barley",
        "startDate": "2023-05-01",
        "endDate": "2023-09-30",
        "active": false
      }
    ]
  }
}
```

**Step 2: Write the failing tests**

`r-package/tests/testthat/test-trials.R`:
```r
library(httptest2)

test_that("get_trials() returns a data frame", {
  with_mock_api({
    con <- bb_connect("https://example.com", "mytoken")
    result <- get_trials(con)
    expect_s3_class(result, "data.frame")
    expect_equal(nrow(result), 2)
    expect_true("trialDbId" %in% names(result))
    expect_true("trialName" %in% names(result))
  })
})

test_that("get_trials() filters by program", {
  with_mock_api({
    con <- bb_connect("https://example.com", "mytoken")
    result <- get_trials(con, program = "AB_Barley")
    expect_s3_class(result, "data.frame")
  })
})
```

**Note on httptest2:** `with_mock_api()` intercepts HTTP requests and serves files from a directory named after the host (`example.com/`). The file path mirrors the URL path. A GET to `/brapi/v1/trials` with no query params serves `example.com/brapi/v1/trials.json`. For requests with query params (like `?programName=AB_Barley`), httptest2 hashes the params into the filename. Run `httptest2::capture_requests()` against a live instance to generate real fixtures if needed.

**Step 3: Run tests — expect FAIL**

```bash
Rscript -e "devtools::test(filter='trials')"
```
Expected: Error — `get_trials` not found

**Step 4: Implement get_trials()**

`r-package/R/trials.R`:
```r
#' Get trials from Breedbase
#'
#' @param con A `bbr_con` object from [bb_connect()].
#' @param program Filter by program name (optional).
#' @param year Filter by year as integer (optional). Maps to `seasonDbId`.
#' @return A data frame of trials.
#' @export
get_trials <- function(con, program = NULL, year = NULL) {
  req <- bbr_request(con, "/brapi/v1/trials")

  if (!is.null(program)) {
    req <- httr2::req_url_query(req, programName = program)
  }
  if (!is.null(year)) {
    req <- httr2::req_url_query(req, seasonDbId = as.character(year))
  }

  resp <- httr2::req_perform(req)
  data <- httr2::resp_body_json(resp, simplifyVector = TRUE)

  as.data.frame(data$result$data)
}
```

**Step 5: Run tests — expect PASS**

```bash
Rscript -e "devtools::test(filter='trials')"
```

**Step 6: Commit**

```bash
git add r-package/R/trials.R r-package/tests/testthat/test-trials.R \
        r-package/tests/testthat/example.com/
git commit -m "feat(bbr): add get_trials()"
```

---

### Task 4: get_germplasm() — TDD

**Files:**
- Modify: `r-package/R/germplasm.R`
- Create: `r-package/tests/testthat/test-germplasm.R`
- Create: `r-package/tests/testthat/example.com/brapi/v1/studies/123/germplasm.json`

**BrAPI background:** Germplasm (accessions) within a study are at `GET /brapi/v1/studies/{studyDbId}/germplasm`. The `study_id` parameter maps to Breedbase's `studyDbId`. Note: what the breeder calls a "trial" in the field (a single location-year experiment) is a "study" in BrAPI. The breeder will get `studyDbId` values from the Breedbase web UI or from the data returned by `get_trials()`.

**Step 1: Create the fixture**

Directory: `r-package/tests/testthat/example.com/brapi/v1/studies/123/`

File: `germplasm.json`
```json
{
  "metadata": {
    "pagination": {"totalCount": 3, "pageSize": 1000, "totalPages": 1, "currentPage": 0},
    "status": [],
    "datafiles": []
  },
  "result": {
    "data": [
      {"germplasmDbId": "g1", "germplasmName": "Harrington", "entryNumber": "1"},
      {"germplasmDbId": "g2", "germplasmName": "CDC Bow",    "entryNumber": "2"},
      {"germplasmDbId": "g3", "germplasmName": "Legacy",     "entryNumber": "3"}
    ]
  }
}
```

**Step 2: Write the failing tests**

`r-package/tests/testthat/test-germplasm.R`:
```r
library(httptest2)

test_that("get_germplasm() returns a data frame", {
  with_mock_api({
    con    <- bb_connect("https://example.com", "mytoken")
    result <- get_germplasm(con, study_id = "123")
    expect_s3_class(result, "data.frame")
    expect_equal(nrow(result), 3)
    expect_true("germplasmDbId" %in% names(result))
    expect_true("germplasmName" %in% names(result))
  })
})
```

**Step 3: Run tests — expect FAIL**

```bash
Rscript -e "devtools::test(filter='germplasm')"
```

**Step 4: Implement get_germplasm()**

`r-package/R/germplasm.R`:
```r
#' Get germplasm for a study
#'
#' @param con A `bbr_con` object from [bb_connect()].
#' @param study_id The `studyDbId` from Breedbase. In BrAPI terminology a
#'   "study" is a single location-year instance of an experiment — what the
#'   breeder typically calls a "trial".
#' @return A data frame of germplasm entries.
#' @export
get_germplasm <- function(con, study_id) {
  path <- paste0("/brapi/v1/studies/", study_id, "/germplasm")
  req  <- bbr_request(con, path)

  resp <- httr2::req_perform(req)
  data <- httr2::resp_body_json(resp, simplifyVector = TRUE)

  as.data.frame(data$result$data)
}
```

**Step 5: Run tests — expect PASS**

```bash
Rscript -e "devtools::test(filter='germplasm')"
```

**Step 6: Commit**

```bash
git add r-package/R/germplasm.R r-package/tests/testthat/test-germplasm.R \
        "r-package/tests/testthat/example.com/brapi/v1/studies/"
git commit -m "feat(bbr): add get_germplasm()"
```

---

### Task 5: get_observations() — TDD

**Files:**
- Modify: `r-package/R/observations.R`
- Create: `r-package/tests/testthat/test-observations.R`
- Create: `r-package/tests/testthat/example.com/brapi/v1/studies/123/observationunits.json`

**BrAPI background:** `GET /brapi/v1/studies/{studyDbId}/observationunits` returns all observation units (plots) with their trait observations. Each unit has an `observations` array containing trait values. The `traits` filter is client-side (Breedbase v1.3 doesn't filter by trait on this endpoint) — `get_observations()` fetches all and filters in R.

**Step 1: Create the fixture**

File: `r-package/tests/testthat/example.com/brapi/v1/studies/123/observationunits.json`
```json
{
  "metadata": {
    "pagination": {"totalCount": 2, "pageSize": 1000, "totalPages": 1, "currentPage": 0},
    "status": [],
    "datafiles": []
  },
  "result": {
    "data": [
      {
        "observationUnitDbId": "ou1",
        "germplasmName": "Harrington",
        "plotNumber": "1",
        "observations": [
          {"observationVariableName": "Yield", "value": "6.2", "observationDbId": "o1"},
          {"observationVariableName": "Height", "value": "92",  "observationDbId": "o2"}
        ]
      },
      {
        "observationUnitDbId": "ou2",
        "germplasmName": "CDC Bow",
        "plotNumber": "2",
        "observations": [
          {"observationVariableName": "Yield",  "value": "5.8", "observationDbId": "o3"},
          {"observationVariableName": "Height",  "value": "88",  "observationDbId": "o4"}
        ]
      }
    ]
  }
}
```

**Step 2: Write the failing tests**

`r-package/tests/testthat/test-observations.R`:
```r
library(httptest2)

test_that("get_observations() returns a data frame", {
  with_mock_api({
    con    <- bb_connect("https://example.com", "mytoken")
    result <- get_observations(con, study_id = "123")
    expect_s3_class(result, "data.frame")
    expect_true("germplasmName" %in% names(result))
    expect_true("trait" %in% names(result))
    expect_true("value" %in% names(result))
  })
})

test_that("get_observations() filters by trait name", {
  with_mock_api({
    con    <- bb_connect("https://example.com", "mytoken")
    result <- get_observations(con, study_id = "123", traits = "Yield")
    expect_equal(unique(result$trait), "Yield")
  })
})

test_that("get_observations() returns all traits when traits=NULL", {
  with_mock_api({
    con    <- bb_connect("https://example.com", "mytoken")
    result <- get_observations(con, study_id = "123")
    expect_true(all(c("Yield", "Height") %in% unique(result$trait)))
  })
})
```

**Step 3: Run tests — expect FAIL**

```bash
Rscript -e "devtools::test(filter='observations')"
```

**Step 4: Implement get_observations()**

`r-package/R/observations.R`:
```r
#' Get observations for a study
#'
#' Returns a tidy data frame with one row per observation unit × trait.
#'
#' @param con A `bbr_con` object from [bb_connect()].
#' @param study_id The `studyDbId` from Breedbase.
#' @param traits Character vector of trait names to return. `NULL` returns all.
#' @return A data frame with columns: `observationUnitDbId`, `germplasmName`,
#'   `plotNumber`, `trait`, `value`.
#' @export
get_observations <- function(con, study_id, traits = NULL) {
  path <- paste0("/brapi/v1/studies/", study_id, "/observationunits")
  req  <- bbr_request(con, path)

  resp <- httr2::req_perform(req)
  data <- httr2::resp_body_json(resp, simplifyVector = FALSE)

  # Unnest: one row per observationUnit × observation
  rows <- lapply(data$result$data, function(unit) {
    lapply(unit$observations, function(obs) {
      list(
        observationUnitDbId      = unit$observationUnitDbId %||% NA_character_,
        germplasmName            = unit$germplasmName        %||% NA_character_,
        plotNumber               = unit$plotNumber           %||% NA_character_,
        trait                    = obs$observationVariableName %||% NA_character_,
        value                    = obs$value                 %||% NA_character_
      )
    })
  })
  rows <- unlist(rows, recursive = FALSE)
  result <- do.call(rbind, lapply(rows, as.data.frame, stringsAsFactors = FALSE))

  if (!is.null(traits)) {
    result <- result[result$trait %in% traits, , drop = FALSE]
  }

  result
}

# NULL-coalescing helper (base R has no %||%)
`%||%` <- function(x, y) if (!is.null(x)) x else y
```

**Step 5: Run tests — expect PASS**

```bash
Rscript -e "devtools::test(filter='observations')"
```

**Step 6: Run all tests and check package**

```bash
Rscript -e "devtools::test()"
Rscript -e "devtools::check()"
```
Expected: all tests pass, 0 errors, 0 warnings (possibly 1 note about package size — ignore)

**Step 7: Commit**

```bash
git add r-package/R/observations.R r-package/tests/testthat/test-observations.R \
        "r-package/tests/testthat/example.com/brapi/v1/studies/123/observationunits.json"
git commit -m "feat(bbr): add get_observations() with trait filter"
```

---

### Task 6: bootstrap.sh — R + RStudio Server

**Files:**
- Modify: `deploy/scripts/bootstrap.sh`

**RStudio Server version pinning:** Check https://posit.co/download/rstudio-server/ for the latest `.deb` for Ubuntu 22.04 Jammy. Pin the version in bootstrap.sh so deployments are reproducible. Update it intentionally when upgrading.

**Step 1: Add R + RStudio Server installs to bootstrap.sh**

Add after the Docker section (after line 27 `sudo apt-get install -y docker-compose-plugin`), before the nginx section:

```bash
echo "=== Bootstrap: installing R ==="
if ! command -v Rscript &>/dev/null; then
    sudo apt-get install -y r-base r-base-dev \
        libssl-dev libcurl4-openssl-dev libxml2-dev
fi

echo "=== Bootstrap: installing RStudio Server ==="
# Check https://posit.co/download/rstudio-server/ for latest Jammy amd64 version
RSTUDIO_DEB="rstudio-server-2024.12.0-467-amd64.deb"
RSTUDIO_URL="https://download2.rstudio.org/server/jammy/amd64/${RSTUDIO_DEB}"

if ! systemctl is-active --quiet rstudio-server 2>/dev/null; then
    wget -q -O "/tmp/${RSTUDIO_DEB}" "${RSTUDIO_URL}"
    sudo dpkg -i "/tmp/${RSTUDIO_DEB}"
    rm "/tmp/${RSTUDIO_DEB}"
    # Restrict RStudio to localhost — nginx handles external access
    sudo mkdir -p /etc/rstudio
    echo "www-address=127.0.0.1" | sudo tee /etc/rstudio/rserver.conf > /dev/null
    sudo systemctl enable rstudio-server
    sudo systemctl start rstudio-server
else
    echo "  RStudio Server already running — skipping"
fi
```

**Step 2: Update bootstrap.sh completion message**

Update the final echo block to mention RStudio:

```bash
echo "  1. Create /etc/breedbase-client.env  (RUNBOOK.md step 4)"
echo "  2. Run: bash /opt/tiller/deploy/scripts/deploy.sh"
echo "     (This will configure nginx for /rstudio and create user accounts)"
```

**Step 3: Test bootstrap.sh syntax**

```bash
bash -n deploy/scripts/bootstrap.sh
```
Expected: no output (no syntax errors)

**Step 4: Commit**

```bash
git add deploy/scripts/bootstrap.sh
git commit -m "feat(deploy): install R and RStudio Server in bootstrap.sh"
```

---

### Task 7: nginx template — /rstudio location block

**Files:**
- Modify: `deploy/nginx/breedbase.conf.template`

**Why WebSocket headers:** RStudio Server uses WebSockets for the IDE connection. Without `Upgrade` and `Connection` headers, the RStudio UI loads but the R session fails to connect. The `proxy_read_timeout 20d` prevents nginx from dropping long-running R sessions.

**Step 1: Add /rstudio location to the nginx template**

Add inside the `server { listen 443 ... }` block, after the `location / { ... }` block:

```nginx
    location /rstudio/ {
        rewrite ^/rstudio/(.*)$ /$1 break;
        proxy_pass         http://localhost:8787;
        proxy_http_version 1.1;
        proxy_set_header   Upgrade           $http_upgrade;
        proxy_set_header   Connection        "upgrade";
        proxy_set_header   Host              $host;
        proxy_set_header   X-Real-IP         $remote_addr;
        proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header   X-Forwarded-Proto $scheme;
        proxy_read_timeout 20d;
        proxy_buffering    off;
    }
```

**Step 2: Verify template renders correctly**

```bash
export CLIENT_HOSTNAME=test.example.com CLIENT_NAME=test \
       DB_PASSWORD=testpass CONTACT_EMAIL=test@example.com

bash deploy/scripts/configure.sh \
    deploy/nginx/breedbase.conf.template \
    /tmp/test-nginx.conf

grep -A 15 "location /rstudio" /tmp/test-nginx.conf
```
Expected: the /rstudio block appears correctly, no `{{...}}` placeholders remaining

**Step 3: Commit**

```bash
git add deploy/nginx/breedbase.conf.template
git commit -m "feat(deploy): add /rstudio nginx proxy to config template"
```

---

### Task 8: deploy.sh — user accounts + bbr install

**Files:**
- Modify: `deploy/scripts/deploy.sh`

**Step 1: Add OS user creation section**

Add after section `--- 1. Load and validate client environment ---` and before section `--- 2. Configure nginx ---`:

```bash
# --- 1b. Create RStudio user accounts ----------------------------------------

echo "=== Creating RStudio user accounts ==="
for user in breeder analyst; do
    if ! id "$user" &>/dev/null; then
        sudo useradd --create-home --shell /bin/bash "$user"
        echo "  Created user: $user (set password manually: sudo passwd $user)"
    else
        echo "  User $user already exists — skipping"
    fi
done
```

**Step 2: Add bbr installation section**

Add after section `--- 11. Install backup cron job ---` and before `--- Done ---`:

```bash
# --- 12. Install bbr R package -----------------------------------------------

echo "=== Installing bbr R package ==="
sudo Rscript -e "
    if (!requireNamespace('remotes', quietly = TRUE)) {
        install.packages('remotes', repos = 'https://cloud.r-project.org', quiet = TRUE)
    }
    remotes::install_local('/opt/tiller/r-package',
                           dependencies = TRUE,
                           upgrade      = 'never',
                           quiet        = TRUE)
    cat('bbr installed successfully\n')
"
```

**Step 3: Add RStudio restart to reload nginx config**

In section `--- 5. Start nginx ---`, after `sudo systemctl enable nginx`, add:

```bash
# Restart RStudio Server to pick up any rserver.conf changes
sudo systemctl restart rstudio-server 2>/dev/null || true
```

**Step 4: Update the Done message**

Add RStudio to the smoke test echo at the end:

```bash
echo "    - https://$CLIENT_HOSTNAME/rstudio/  opens RStudio Server login"
echo "    - Login with breeder or analyst (passwords set via: sudo passwd <user>)"
```

**Step 5: Test deploy.sh syntax**

```bash
bash -n deploy/scripts/deploy.sh
```
Expected: no output

**Step 6: Commit**

```bash
git add deploy/scripts/deploy.sh
git commit -m "feat(deploy): create RStudio user accounts and install bbr"
```

---

### Task 9: RUNBOOK — RStudio section

**Files:**
- Modify: `deploy/RUNBOOK.md`

**Step 1: Add RStudio section after "5–10. Deploy" and before "11. Smoke test checklist"**

```markdown
---

## 11a. Set RStudio user passwords

`deploy.sh` creates `breeder` and `analyst` accounts with no password. Set passwords
before handing access to users:

```bash
sudo passwd breeder
sudo passwd analyst
```

Choose strong passwords. These are used to log in to RStudio Server at
`https://$CLIENT_HOSTNAME/rstudio/`.

---

## 11b. Configure .Renviron for each RStudio user

Each user needs their Breedbase API token in their `.Renviron` file.

**Get the API token from Breedbase:**
1. Log in to `https://$CLIENT_HOSTNAME` as admin
2. Go to Admin → Manage Users → select the user's Breedbase account
3. Copy or generate their API token

**Set .Renviron for each user** (run as each user, or `sudo -u <user>`):

```bash
sudo -u breeder tee /home/breeder/.Renviron > /dev/null <<EOF
BB_URL=https://${CLIENT_HOSTNAME}
BB_TOKEN=<paste token here>
EOF
sudo chmod 600 /home/breeder/.Renviron
```

Repeat for `analyst`.

**Verify it works** — log in to RStudio as the user and run:

```r
library(bbr)
con <- bb_connect()
con  # should print <bbr_con> with URL
```
```

**Step 2: Add RStudio items to "11. Smoke test checklist"**

Add to the existing checklist:

```markdown
- [ ] `https://$CLIENT_HOSTNAME/rstudio/` opens the RStudio Server login page
- [ ] Login as `breeder` succeeds
- [ ] `library(bbr); bb_connect()` runs without error in RStudio
- [ ] `get_trials(bb_connect())` returns a data frame (may be empty if no data yet)
```

**Step 3: Add RStudio to the Maintenance section**

```markdown
**RStudio Server:**
```bash
sudo systemctl status rstudio-server
sudo systemctl restart rstudio-server
# Logs:
sudo journalctl -u rstudio-server -f
```
```

**Step 4: Commit**

```bash
git add deploy/RUNBOOK.md
git commit -m "docs: add RStudio Server deployment steps to RUNBOOK"
```

---

### Task 10: Final verification

**Step 1: Run R CMD check on bbr**

```bash
cd r-package && Rscript -e "devtools::check()"
```
Expected: 0 errors, 0 warnings (notes about non-standard directory are acceptable)

**Step 2: Verify all bash scripts parse cleanly**

```bash
bash -n deploy/scripts/bootstrap.sh
bash -n deploy/scripts/deploy.sh
bash -n deploy/scripts/configure.sh
```
Expected: no output

**Step 3: Verify nginx template renders with no placeholders remaining**

```bash
export CLIENT_HOSTNAME=test.example.com CLIENT_NAME=test \
       DB_PASSWORD=testpass CONTACT_EMAIL=test@example.com

bash deploy/scripts/configure.sh \
    deploy/nginx/breedbase.conf.template /tmp/final-nginx.conf

grep '{{' /tmp/final-nginx.conf && echo "FAIL: unreplaced placeholders" || echo "OK"
```
Expected: `OK`

**Step 4: Final commit**

```bash
git add -A
git status  # verify nothing unexpected
git commit -m "chore: finalize RStudio Server + bbr delivery"
```
